import {
	existsSync,
	mkdirSync,
	readdirSync,
	statSync,
	writeFileSync,
} from "node:fs";
import path from "node:path";
import process from "node:process";
import { SUPPORTED_LOCALES } from "../../src/i18n/config";

const LOCALES_DIR = path.join(process.cwd(), "src/locales");
const OUTPUT_FILE = path.join(process.cwd(), "src/i18n/catalog-manifest.ts");
const SUPPORTED_LOCALE_SET = new Set<string>(SUPPORTED_LOCALES);
const INCLUDED_ENTRY_PREFIXES = ["src/app/[lang]/"];
const INCLUDED_ENTRY_PATHS = new Set<string>([
	"src/components/layout/site-header",
	"src/components/layout/mobile-header-menu",
	"src/components/layout/site-footer",
	"src/components/layout/site-brand",
	"src/components/layout/theme-toggle",
	"src/components/copy-install-command",
	"src/components/skill-card",
	"src/components/skills-library-section",
]);

function shouldIncludeEntry(entry: string): boolean {
	if (INCLUDED_ENTRY_PATHS.has(entry)) {
		return true;
	}

	return INCLUDED_ENTRY_PREFIXES.some((prefix) => entry.startsWith(prefix));
}

function normalizePath(input: string): string {
	return input.split(path.sep).join("/");
}

function listFiles(dir: string): string[] {
	if (!existsSync(dir)) return [];

	const files: string[] = [];
	for (const entry of readdirSync(dir)) {
		const fullPath = path.join(dir, entry);
		const stats = statSync(fullPath);
		if (stats.isDirectory()) {
			files.push(...listFiles(fullPath));
			continue;
		}
		if (stats.isFile()) {
			files.push(fullPath);
		}
	}
	return files;
}

function buildManifest(): Record<string, Record<string, string>> {
	const fileMap: Record<string, Record<string, string>> = {};
	const files = listFiles(LOCALES_DIR).filter((file) => file.endsWith(".mjs"));

	for (const file of files) {
		const rel = normalizePath(path.relative(LOCALES_DIR, file));
		const locale = path.basename(rel, ".mjs");
		const entry = normalizePath(path.dirname(rel));

		if (entry === ".") {
			continue;
		}
		if (!shouldIncludeEntry(entry)) {
			continue;
		}
		if (!SUPPORTED_LOCALE_SET.has(locale)) {
			continue;
		}

		fileMap[entry] ??= {};
		fileMap[entry][locale] = `../locales/${entry}/${locale}.mjs`;
	}

	return fileMap;
}

function renderManifest(
	manifest: Record<string, Record<string, string>>,
): string {
	const entries = Object.keys(manifest).sort();
	const lines: string[] = [];
	const identifierReg = /^[$A-Z_a-z][$\w]*$/;
	const formatKey = (key: string) =>
		identifierReg.test(key) ? key : JSON.stringify(key);

	lines.push("// Generated by scripts/i18n/manifest.ts. Do not edit manually.");
	lines.push('import type { Messages } from "@lingui/core";');
	lines.push("");
	lines.push("type CatalogModule = {");
	lines.push("\tdefault?: Messages | { messages?: Messages };");
	lines.push("\tmessages?: Messages;");
	lines.push("};");
	lines.push("export type CatalogLoader = () => Promise<CatalogModule>;");
	lines.push(
		"export type CatalogManifest = Record<string, Record<string, CatalogLoader>>;",
	);
	lines.push("");
	lines.push("export const catalogManifest: CatalogManifest = {");

	for (const entry of entries) {
		lines.push(`\t${formatKey(entry)}: {`);
		const locales = Object.keys(manifest[entry] ?? {}).sort();
		for (const locale of locales) {
			const importPath = manifest[entry]?.[locale];
			if (!importPath) continue;
			lines.push(
				`\t\t${formatKey(locale)}: () => import(${JSON.stringify(importPath)}),`,
			);
		}
		lines.push("\t},");
	}

	lines.push("};");
	lines.push("");

	return lines.join("\n");
}

function main(): void {
	const manifest = buildManifest();
	const content = renderManifest(manifest);

	mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
	writeFileSync(OUTPUT_FILE, content, "utf8");

	console.log(
		`[i18n] wrote catalog manifest: ${path.relative(process.cwd(), OUTPUT_FILE)}`,
	);
	console.log(`[i18n] entries: ${Object.keys(manifest).length}`);
}

main();
