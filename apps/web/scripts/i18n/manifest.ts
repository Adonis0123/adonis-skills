import {
	existsSync,
	mkdirSync,
	readFileSync,
	readdirSync,
	statSync,
	writeFileSync,
} from "node:fs";
import path from "node:path";
import process from "node:process";
import { pathToFileURL } from "node:url";
import { SUPPORTED_LOCALES } from "../../src/i18n/config";
import {
	CATALOG_FILE_EXTENSIONS,
	entryOwnsCatalogContent,
	normalizePath,
} from "./catalog-ownership";
import { resolveSourceLocale } from "./source-locale";

const LOCALES_DIR = path.join(process.cwd(), "src/locales");
const OUTPUT_FILE = path.join(process.cwd(), "src/i18n/catalog-manifest.ts");
const SUPPORTED_LOCALE_SET = new Set<string>(SUPPORTED_LOCALES);
const INCLUDED_ENTRY_PREFIXES = ["src/app/[lang]/", "src/components/"];

export interface BuildManifestOptions {
	localesDir?: string;
	sourceLocale: string;
	supportedLocales?: ReadonlySet<string>;
	includedEntryPrefixes?: readonly string[];
}

export interface BuildManifestResult {
	manifest: Record<string, Record<string, string>>;
	candidateEntries: number;
}

function shouldIncludeEntry(
	entry: string,
	includedEntryPrefixes: readonly string[],
): boolean {
	return includedEntryPrefixes.some((prefix) => entry.startsWith(prefix));
}

function listFiles(dir: string): string[] {
	if (!existsSync(dir)) return [];

	const files: string[] = [];
	for (const entry of readdirSync(dir)) {
		const fullPath = path.join(dir, entry);
		const stats = statSync(fullPath);
		if (stats.isDirectory()) {
			files.push(...listFiles(fullPath));
			continue;
		}
		if (stats.isFile()) {
			files.push(fullPath);
		}
	}
	return files;
}

function listCatalogFiles(dir: string): string[] {
	return listFiles(dir).filter((filePath) =>
		CATALOG_FILE_EXTENSIONS.has(path.extname(filePath).toLowerCase()),
	);
}

function entryOwnsCatalog(
	localesDir: string,
	entry: string,
	sourceLocale: string,
): boolean {
	const poPath = path.join(localesDir, entry, `${sourceLocale}.po`);
	if (!existsSync(poPath)) return false;

	const content = readFileSync(poPath, "utf8");
	return entryOwnsCatalogContent(entry, content);
}

export function buildManifest({
	localesDir = LOCALES_DIR,
	sourceLocale,
	supportedLocales = SUPPORTED_LOCALE_SET,
	includedEntryPrefixes = INCLUDED_ENTRY_PREFIXES,
}: BuildManifestOptions): BuildManifestResult {
	const fileMap: Record<string, Record<string, string>> = {};
	const files = listFiles(localesDir).filter((file) => file.endsWith(".mjs"));
	const ownershipCache = new Map<string, boolean>();
	const candidateEntries = new Set<string>();

	for (const file of listCatalogFiles(localesDir)) {
		const rel = normalizePath(path.relative(localesDir, file));
		const entry = normalizePath(path.dirname(rel));
		if (entry === ".") continue;
		if (!shouldIncludeEntry(entry, includedEntryPrefixes)) continue;
		candidateEntries.add(entry);
	}

	for (const file of files) {
		const rel = normalizePath(path.relative(localesDir, file));
		const locale = path.basename(rel, ".mjs");
		const entry = normalizePath(path.dirname(rel));

		if (entry === ".") continue;
		if (!shouldIncludeEntry(entry, includedEntryPrefixes)) continue;
		if (!supportedLocales.has(locale)) continue;

		if (!ownershipCache.has(entry)) {
			ownershipCache.set(
				entry,
				entryOwnsCatalog(localesDir, entry, sourceLocale),
			);
		}
		if (!ownershipCache.get(entry)) continue;

		fileMap[entry] ??= {};
		fileMap[entry][locale] = `../locales/${entry}/${locale}.mjs`;
	}

	return {
		manifest: fileMap,
		candidateEntries: candidateEntries.size,
	};
}

export function renderManifest(
	manifest: Record<string, Record<string, string>>,
): string {
	const entries = Object.keys(manifest).sort();
	const lines: string[] = [];
	const identifierReg = /^[$A-Z_a-z][$\w]*$/;
	const formatKey = (key: string) =>
		identifierReg.test(key) ? key : JSON.stringify(key);

	lines.push("// Generated by scripts/i18n/manifest.ts. Do not edit manually.");
	lines.push('import type { Messages } from "@lingui/core";');
	lines.push("");
	lines.push("type CatalogModule = {");
	lines.push("\tdefault?: Messages | { messages?: Messages };");
	lines.push("\tmessages?: Messages;");
	lines.push("};");
	lines.push("export type CatalogLoader = () => Promise<CatalogModule>;");
	lines.push(
		"export type CatalogManifest = Record<string, Record<string, CatalogLoader>>;",
	);
	lines.push("");
	lines.push("export const catalogManifest: CatalogManifest = {");

	for (const entry of entries) {
		lines.push(`\t${formatKey(entry)}: {`);
		const locales = Object.keys(manifest[entry] ?? {}).sort();
		for (const locale of locales) {
			const importPath = manifest[entry]?.[locale];
			if (!importPath) continue;
			lines.push(
				`\t\t${formatKey(locale)}: () => import(${JSON.stringify(importPath)}),`,
			);
		}
		lines.push("\t},");
	}

	lines.push("};");
	lines.push("");

	return lines.join("\n");
}

export function runManifestScript(): void {
	const { sourceLocale, warnings } = resolveSourceLocale();
	for (const warning of warnings) {
		console.warn(warning);
	}

	const { manifest, candidateEntries } = buildManifest({ sourceLocale });
	const content = renderManifest(manifest);

	mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
	writeFileSync(OUTPUT_FILE, content, "utf8");

	const kept = Object.keys(manifest).length;
	const skipped = candidateEntries - kept;

	console.log(
		`[i18n] wrote catalog manifest: ${path.relative(process.cwd(), OUTPUT_FILE)}`,
	);
	console.log(
		`[i18n] entries: ${kept}${skipped > 0 ? ` (skipped ${skipped} without own messages)` : ""}`,
	);
}

if (
	typeof process.argv[1] === "string" &&
	pathToFileURL(process.argv[1]).href === import.meta.url
) {
	runManifestScript();
}
