# Verification Rubric

本文件定义"问题是否成立"的统一判定标准。

## 1. 裁决标准

### 1.1 成立

满足以下任一条件：

- 代码中可直接定位到与问题描述一致的缺陷
- 报告中的路径/行号与实际代码语义一致
- 复核后确认问题尚未修复

### 1.2 不成立

满足以下任一条件：

- 报告描述与代码实际行为不符
- 报告引用的代码已在当前变更中修复
- 问题基于错误前提（例如误读 API、误判作用域）

### 1.3 待确认

满足以下任一条件：

- 路径或行号缺失，无法定位
- 需要运行时信息或外部上下文，当前证据不足
- 报告描述过于抽象，无法映射到具体代码点

## 2. 证据优先级

从高到低：

1. 当前工作区文件与行级上下文
2. `git diff --cached` 的实际差异
3. 历史版本对比（`git show HEAD:<path>`）
4. 报告原文中的主观判断

当高优先级证据与低优先级冲突时，采用高优先级证据。

## 3. 严重度与"是否需要修改"映射

4 级严重度映射（兼容 staged-changes-review v2 输出）：

| 裁决 | 严重度 | 是否需要修改 |
|------|--------|-------------|
| 成立 | CRITICAL | 必须修改 |
| 成立 | HIGH | 需要修改 |
| 成立 | MEDIUM | 建议修改 |
| 成立 | LOW | 可选修改 |
| 不成立 | Any | 不需要修改 |
| 待确认 | Any | 暂不修改，先补充信息 |

**兼容说明**: 如果输入使用旧版 3 级严重度（高/中/低），按以下规则映射：
- 高 → HIGH
- 中 → MEDIUM
- 低 → LOW

## 4. 规则类型感知

当输入包含 ruleId 前缀时，验证者可利用规则类型优化复核策略：

| 规则前缀 | 复核方法 |
|----------|---------|
| SEC-* | 优先用 grep 验证模式是否真实匹配 |
| STR-* | 确认是否为新增行（非已有代码） |
| ASYNC-* | 检查上下文是否已有 try-catch 或 .catch |
| LOGIC-* | 读取完整函数上下文验证语义判断 |
| BREAK-* | 对比 HEAD 版本确认是否为破坏性变更 |
| REACT-* | 读取组件完整上下文验证 Rules of Hooks、渲染逻辑和副作用清理 |
| PERF-* | 分析 async 函数中的 await 调用序列，确认是否为真正独立的并行候选 |

## 5. 指纹利用

当输入包含指纹 (`{ruleId}:{file}:{line}`) 时：
- 直接定位到精确的文件和行号
- 跳过模糊搜索，提高验证效率
- 在输出中保留原始指纹以便追踪

## 6. 常见误判清单

- 把"风格建议"误判为"功能缺陷"
- 只看片段，忽略调用链或上游约束
- 在已修复代码上重复报错（报告滞后）
- 误把测试辅助代码当生产路径
- STR 类规则误判：已有的 console.log/TODO 不应报为新增
- ASYNC 类规则误判：外层已有 try-catch 但 grep 仅扫描单行
- SEC-005 误判：Python `re.compile()` 或 `builtins.compile()` 不是安全风险
- STR-001 误判：`scripts/`、`cli/`、`scaffold/` 目录下的 Python `print()` 是合法 CLI 输出
- REACT-001 误判：只有在组件函数体内部的条件/循环中调用 Hook 才算违规，顶层调用是合法的
- REACT-003 误判：若 useEffect 返回值中有 `removeEventListener`，即使在不同行也是合法 cleanup
- PERF-001 误判：若两个 await 的结果存在依赖关系（第二个依赖第一个的返回值），不能并行化，不应报告
